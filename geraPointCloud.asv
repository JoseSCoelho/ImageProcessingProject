function pc = geraPointCloud(imgseq, G, w_frame, max_n_points)
%UNTITLED Summary of this function goes here
%   Detailed explanation goes here

global rotations
global translations
global camera_params

numImgs = length(imgseq);

% gera todas as coordenadas possíveis
[rows, cols, ~] = size(imread(imgseq(1).rgb));
[vect_coluna, vect_linha]= meshgrid(1:cols,1:rows);
pixeis_all = [vect_coluna(:), vect_linha(:)];

pc = pointCloud(double.empty(0, 3));

for i = 1:numImgs
    % Gera as point cloud completas das imagens A e B
    disp(i)
    
    % Lê a imagem i
    im = imread(imgseq(i).rgb);
    depth_array = imread(imgseq(i).depth);
    [virtual_rgb_A, virtual_depth_A] = get_virtual_img(depth_array, im, camera_params);
    
    %Point cloud na perspetiva da camara i
    PC_orig = generate_PC(virtual_depth_A, pixeis_all', virtual_rgb_A, camera_params);
%     PC_atual = reshape(rotations(1, i, :, :), [3, 3]) * PC_orig.Location' + reshape(translations(1, i, :, :), [3, 1]);
    PC_orig = pcdownsample(PC_orig, 'gridAverage', 0.05);
    % Transforma a point cloud para a perspetiva da camara world frame
    PC_atual = PC_orig.Location';
    R_all = eye(3);
    T_all = zeros(3, 1);
    if i ~=  w_frame
        path = shortestpath(G,i,w_frame);
        for j = 2: length(path) 
%             T_all = R_all*reshape(translations(path(j), path(j-1), :, :), [3, 1]) + T_all + reshape(translations(path(j), path(j-1), :, :), [3, 1]) + T_all;
%             R_all = reshape(rotations(path(j), path(j-1), :, :), [3, 3]) * R_all;
            PC_atual =  reshape(rotations(path(j), path(j-1), :, :), [3, 3]) * PC_atual + reshape(translations(path(j), path(j-1), :, :), [3, 1]);
        end 
%         PC_atual = R_all*PC_orig.Location' + T_all;
    end
        
    % Point cloud ja na trasnformacao da camara
    pc2 = pointCloud(PC_atual', 'color', uint8([PC_orig.Color]));
    
    pc = pcmerge(pc, pc2, 0.05);
    if length(pc.Location) > max_n_points
        
    end
end
end

